/**
  * @file ${obj.name.lower()}_slave.c
  * @author generated by mrt-device utility 
  * @link [https://github.com/uprev-mrt/mrtutils/wiki/mrt-device]
  * @brief Device driver for ${obj.name} device
  *
  */

#include "${obj.name.lower()}_slave.h"

${obj.name.lower()}_slave_t REGS = {
    .mData = {
% for key,reg in obj.regs.items():
    .${"m" + obj.camelCase(reg.name)} = ${reg.default},
% endfor        
    },
    .mRegs = {
% for key,reg in obj.regs.items():
    { .mFlags = SLAVE_REG_PERM_${reg.perm}} , .mSize = ${reg.size}},
% endfor   
    },
    .mCurrentReg = 0,
    .mCRIO =0 ,
    .mCursor = 0,
    .mAddrBytes = 0,
    .mState = SLAVE_STATE_ADDRESS,
    .mFlags = 0,
};

uint8_t* DATA = (uint8_t*)REGS.mData;


static void go_to_register(addr_t addr)
{
    REGS.mCurrentReg = 0;
    REGS.mCRIO = 0;
    REGS.mCursor =  addr; 

    for(int i = 0; i < ${obj.name.upper()}_REG_COUNT; i++)
    {
        if( addr < REGS.mRegs[i+1])
        {
            REGS.mCurrentReg = &REGS.mRegs[i];     //Set current reg
        }
    }
}

/**
 * @brief initializes ${obj.name} slave registers
 * @param fifoDepth size of rxFifo to use
 */
void ${obj.prefix.lower()}_slave_init( )
{

}

/**
 * @brief feed byte into fifo
 * @param dev ptr to ${obj.name} device
 * @param data byte to feed 
 */
void ${obj.prefix.lower()}_slave_put( uint8_t data )
{
    switch (REGS.mState)
    {
        case SLAVE_STATE_ADDRESS:
            REGS.mAddress = (REGS.mAddress << 8) | data;
            if(++REGS.mAddrBytes == ${obj.name.upper()}_REG_ADDR_SIZE)
            {
                go_to_register(REGS.mAddress);
                REGS.mState = SLAVE_STATE_DATA;
            }
            break;
        case SLAVE_STATE_DATA:
            if(REGS.mCurrentReg.mFlags & SLAVE_REG_PERM_W)
            {
                DATA[REGS.mCursor] = data;
                REGS.mCurrentReg->mFlags |= SLAVE_REG_ACESS_W;
                REGS.mFlags |= SLAVE_REG_ACESS_W;
                REGS.mCursor++;
                if(REGS.mCursor == REGS.mCurrentReg.mStart + REGS.mCurrentReg.mSize)
                {
                    REGS.mCurrentReg += sizeof(slave_reg_t);
                }
            }
        default:

            break;
    }
}

uint8_t ${obj.prefix.lower()}_slave_get(void)
{
     if(REGS.mCurrentReg.mFlags & SLAVE_REG_PERM_R)
     {
        REGS.mCurrentReg->mFlags |= SLAVE_REG_ACESS_R;   //Mark as Read
        REGS.mFlags |= SLAVE_REG_ACESS_R;
        return DATA[REGS.mCursor++];                   //Return data
     }

     return 0;
}


/*user-block-bottom-start*/
/*user-block-bottom-end*/

