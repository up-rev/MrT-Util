/**
  * @file ${obj.name.lower()}_dev.h
  * @author generated by mrt-device.py
  * @brief register defintions for ${obj.name} device
  * 
  */

#ifdef __cplusplus
extern "C"
{
#endif

#include <stdint.h>
#include <stdbool.h>
#include "Devices/RegDevice/register_device.h"

/*USER_TOP*/

/*END_USER_TOP*/

% if "I2C" in obj.bus.upper():
#define ${obj.prefix.upper()}_I2C_ADDRESS obj.i2c_addr
% endif

/*******************************************************************************
  Registers
*******************************************************************************/

% for key,reg in obj.regs.items():
extern mrt_reg_t* ${obj.prefix + "_" + reg.name};
% endfor


/*******************************************************************************
  Flags and Values                                                                                 
*******************************************************************************/

% for key,reg in obj.regs.items():
% if (len(reg.fields) + len(reg.flags)) > 0 :
/* ${reg.name} */
    %for flag in reg.flags:
#define ${obj.prefix +"_"+reg.name+"_"+flag.name}                       ${reg.formatHex(flag.val)}
    %endfor
    %for field in reg.fields:
    %for val in field.vals:
#define ${obj.prefix +"_"+reg.name+"_"+field.name +"_" + val.name}      ${reg.formatHex(val.val)}
    %endfor
    %endfor
% endif
% endfor

/*******************************************************************************
  Functions                                                                                
*******************************************************************************/

typedef struct{
    mrt_regdev_t mRegDev; //ptr to register base device 
    % for key,reg in obj.regs.items():
    mrt_reg_t* ${"m" + obj.camelCase(reg.name)};  //${reg.desc}
% endfor
/*USER_STRUCT*/

/*END_USER_STRUCT*/
}${obj.name}_t;

% if "I2C" in obj.bus.upper():
/**
 * @brief initializes ${obj.name} device for i2c bus
 * @param dev ptr to ${obj.name} device
 * @param i2c handle for i2c bus
 */
mrt_status_t ${obj.name}_init_i2c(${obj.name}_t* dev, mrt_i2c_handle_t i2c);
% endif
% if "SPI" in obj.bus.upper():
/**
 * @brief initializes ${obj.name} device for i2c bus
 * @param dev ptr to ${obj.name} device
 * @param spi handle for i2c bus
 */
mrt_status_t ${obj.prefix}_init_spi(${obj.name}_t* dev, mrt_spi_handle_t spi);
% endif


/**
  *@brief writes register of device
  *@param dev ptr to ${obj.name} device
  *@param reg ptr to register definition
  *@param data ptr to data to be written
  *@return status (type defined by platform)
  */
#define ${obj.prefix +"_write_reg"}(dev, reg, data) regdev_write_reg(&dev->mRegDev, reg, data);

/**
  *@brief reads register of device
  *@param dev ptr to ${obj.name} device
  *@param reg ptr to register definition
  *@param data ptr to store data
  *@return bytes read
  */
#define ${obj.prefix +"_read_reg"}(dev, reg, data) regdev_read_reg(&dev->mRegDev, reg, data);
## 
## % for key,reg in obj.regs.items():
## % if len(reg.fields)  > 0 :
## 
##     %for field in reg.fields:
## /**
##  * @brief reads the ${field.name} field from the device 
##  * @param dev ptr to ${obj.name} device
##  */
## ${reg.type} ${obj.prefix +"_get_"+ reg.name.lower()+"_"+field.name.lower()}(${obj.name}_t* dev);
## 
## /**
##  * @brief writes the ${field.name} field to the device 
##  * @param dev ptr to ${obj.name} device
##  * @param val value to write
##  */
## mrt_status_t ${obj.prefix +"_set_"+ reg.name.lower()+"_"+field.name.lower()}(${obj.name}_t* dev, ${reg.type} val);
##     %endfor
## % endif
## % endfor


/*USER_FUNCTIONS*/

/*END_USER_FUNCTIONS*/

#ifdef __cplusplus
}
#endif
